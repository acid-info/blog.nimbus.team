"use strict";(self.webpackChunklogos_blog_template=self.webpackChunklogos_blog_template||[]).push([[822],{10711:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/nimbus-2022-recap","metadata":{"permalink":"/nimbus-2022-recap","source":"@site/posts/nimbus-2022-recap.md","title":"Nimbus client 2022 year-end recap","description":"As 2022 winds down, the Nimbus research team reflects on another year of building the infrastructure needed to maximally decentralize the Ethereum network.","date":"2022-12-30T10:00:00.000Z","formattedDate":"December 30, 2022","tags":[],"readingTime":2.07,"hasTruncateMarker":true,"authors":[{"name":"Status","key":"status"}],"frontMatter":{"layout":"post","title":"Nimbus client 2022 year-end recap","description":"As 2022 winds down, the Nimbus research team reflects on another year of building the infrastructure needed to maximally decentralize the Ethereum network.","date":"2022-12-30T10:00","authors":"status","published":true},"nextItem":{"title":"Unbundling the Nimbus consensus client - Part one","permalink":"/unbundling-nimbus-client-1"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/nimbus-2022-recap/header.jpeg)\\n\\nAs 2022 winds down, the Nimbus research team reflects on another year of building the infrastructure needed to maximally decentralize the Ethereum network. Here\'s our recap of updates to the Nimbus consensus client over the past 12 months.\\n\\n## Nimbus\' 2022 unpacked\\n\\nThe broader Ethereum ecosystem enjoyed a momentous 2022. Taking center stage, of course, was the Mainnet Merge \u2014 arguably the most ambitious software update ever orchestrated.\\n\\nThis year has been equally important for the Nimbus client. Among the 20 major and minor releases shipped, there were several significant improvements, changes and feature updates made to the Nimbus client in the last 12 months.\\n\\nSome of 2022\'s key highlights include:\\n\\n1. The long-awaited [split client mode](https://github.com/status-im/nimbus-eth2/issues/3088). This mode enables a more flexible setup: running the Nimbus validator client independently of the beacon node. Through the validator client, advanced node operators such as institutional users and pool operators can take advantage of features like redundant beacon nodes, enhanced validator privacy and distributed keystores. Meanwhile, existing users can still use the streamlined stand-alone beacon node setup, as this mode of operation is continued to be supported and improved.  \\n\\n2. Marked enhancements leading up to a successful Ethereum Mainnet Merge and the stable performance of Nimbus in the post-merge network.\\n\\n3. Support for [trusted node sync](https://nimbus.guide/trusted-node-sync.html) (also known as checkpoint sync).  \\n\\n4. Support for [external block builders](https://nimbus.guide/external-block-builder.html) \u2014 aka MEV \u2014 leading up to the Merge.  \\n\\n5. Support for the Ethereum-defined REST API endpoints for light client sync.  \\n\\n6. Beta release for the [Nimbus stand-alone light client](https://nimbus.guide/el-light-client.html). It can be used to run any execution client without requiring a full-blown beacon node.  \\n\\n7. Improved metrics to [track validator activity](https://nimbus.guide/validator-monitor.html).  \\n\\n8. Continued improvement in [client efficiency](https://github.com/status-im/nimbus-eth2/releases/tag/v22.12.0). Now Nimbus requires less CPU, lower bandwidth and smaller memory space.  \\n\\n9. Support for the [Keymanager API](https://nimbus.guide/keymanager-api.html) and remote keystores. With the Keymanager API, users can add, remove and migrate validators on the fly.  \\n\\n10. Significant improvement in the [Nimbus guide](https://nimbus.guide/) in terms of content and coverage.\\n\\nThe Nimbus team is grateful to the many contributors, community champions and users who collectively pushed for greater client diversity in the network, shared valuable feedback and celebrated each milestone with us.\\n\\nAs we conclude the Year of the Panda, we look forward to the Year of the Owl alongside the community.\\n\\n_Check our blog and follow our social channels to stay up to date with all the latest Nimbus ecosystem developments:_\\n\\n- [Blog](https://our.status.im/tag/nimbus/)\\n\\n- [Twitter](https://twitter.com/ethnimbus)\\n\\n- [Discord](https://discord.com/invite/qnjVyhatUa)\\n\\n- [GitHub](https://github.com/status-im)"},{"id":"/unbundling-nimbus-client-1","metadata":{"permalink":"/unbundling-nimbus-client-1","source":"@site/posts/unbundling-nimbus-client-1.md","title":"Unbundling the Nimbus consensus client - Part one","description":"Nimbus has released a production-ready version of its validator client, addressing a key demand from node operators and advanced users.","date":"2022-12-30T09:00:00.000Z","formattedDate":"December 30, 2022","tags":[],"readingTime":2.01,"hasTruncateMarker":true,"authors":[{"name":"Status","key":"status"}],"frontMatter":{"layout":"post","title":"Unbundling the Nimbus consensus client - Part one","description":"Nimbus has released a production-ready version of its validator client, addressing a key demand from node operators and advanced users.","authors":"status","date":"2022-12-30T09:00","published":true},"prevItem":{"title":"Nimbus client 2022 year-end recap","permalink":"/nimbus-2022-recap"},"nextItem":{"title":"Nimbus - checkpoint sync, era files, Vouch","permalink":"/nimbus-update-march"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/unbundling-nimbus-client-1/header.jpeg)\\n\\nNimbus has released a production-ready version of its validator client, addressing a key demand from node operators and advanced users. The client is highly performant and requires low resources, allowing it to run on a range of devices \u2014 from embedded systems to enterprise servers.\\n\\nBy default, the Nimbus consensus client\'s design allows validators to be run directly from the beacon node, simplifying validator setup. This makes it an ideal choice for solo-stakers, and select node operators that want to use the Nimbus beacon node. However, it made it difficult for operators to use Nimbus in their existing setups, which often feature one or more client beacon nodes interacting with multiple validator clients.\\n\\nFor example, one node operator runs a Teku beacon node with Teku and LH validator clients. Another operator runs a Vouch-based setup with four different client beacon nodes and a Vouch validator client. This also includes node operators in the Rocket Pool network that run several mini-pools. Each operator has fine-tuned their setup for redundancy, performance and resource consistency. It was understandably challenging for these users to directly use the default Nimbus setup of an integrated beacon node and validator client, which would mean a completely different stack to maintain and manage.\\n\\nRelease v22.11.0 allows users to run the Nimbus validator client independently with beacon nodes from other clients, giving operators greater flexibility and the ability to introduce Nimbus into their existing setups with minimal change. This configuration is ideal for operators running hundreds to thousands of validators.\\n\\nAdditionally, the new release includes improvements and fixes. For example, the beacon node is now compatible with validator clients taking advantage of the /eth/v1/beacon/blinded_blocks endpoint, and enables much faster loading of the validator keystore during startup.\\n\\nNimbus\'s privacy characteristics, including its low public profile and support for publishing blocks to separate nodes (such that the validator cannot be matched to its IP address by listening to attestation traffic), make it an attractive choice for advanced users and node operators.\\n\\nThe Nimbus team will continue to support and improve the standalone beacon node setup for individual users and hope to see more operators include the Nimbus validator client in their fleet to improve overall client diversity across the Ethereum network.\\n\\nCheck our blog and follow our social channels to stay up to date with all the latest Nimbus ecosystem developments:\\n\\n- [Blog](https://our.status.im/tag/nimbus/)\\n\\n- [Twitter](https://twitter.com/ethnimbus)\\n\\n- [Discord](https://discord.com/invite/qnjVyhatUa)\\n\\n- [GitHub](https://github.com/status-im)"},{"id":"/nimbus-update-march","metadata":{"permalink":"/nimbus-update-march","source":"@site/posts/nimbus-update-march.md","title":"Nimbus - checkpoint sync, era files, Vouch","description":"header-image","date":"2022-03-02T10:00:00.000Z","formattedDate":"March 2, 2022","tags":[],"readingTime":10.7,"hasTruncateMarker":true,"authors":[{"name":"Status","key":"status"}],"frontMatter":{"layout":"post","title":"Nimbus - checkpoint sync, era files, Vouch","date":"2022-03-02T10:00","authors":"status","published":true},"prevItem":{"title":"Unbundling the Nimbus consensus client - Part one","permalink":"/unbundling-nimbus-client-1"},"nextItem":{"title":"Nimbus Consensus Layer - past, present, and future","permalink":"/nimbus-consensus-layer-2122"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/nimbus-2022-recap/header.jpeg)\\n\\n_(image of the [Lennon Wall](https://en.m.wikipedia.org/wiki/Lennon_Wall) courtesy of [IFMSA](https://ifmsa.org/wall-peace-freedom/))_  \\n  \\n_As these notes were being written, Putin\'s senseless war in Ukraine left nobody untouched and Status is no exception: Our Ukrainian contributors have been forced into bomb shelters with their families as brutalities increase: here are several ways that you can help: https://hrf.org/how-to-support-ukrainians/_  \\n  \\n_In addition, \xa0a growing number of civilians in Russia and Ukraine are using the Tor project to communicate, access news, and get around censorship. You can help them by setting up a Tor bridge: [https://community.torproject.org/relay/setup/bridge/](https://community.torproject.org/relay/setup/bridge/)_\\n\\nTwo weeks ago we published Nimbus `v1.7.0`, a particularly feature-packed [release](https://github.com/status-im/nimbus-eth2/releases/tag/v1.7.0) for our consensus layer client.  \\n\\n> \\"So far, so good\\" [https://t.co/g7L62tq8jy](https://t.co/g7L62tq8jy) [pic.twitter.com/ahshpXUZaq](https://t.co/ahshpXUZaq)\\n> \\n> \u2014 Jacek Sieka (@jcksie) [February 17, 2022](https://twitter.com/jcksie/status/1494381339273056259?ref_src=twsrc%5Etfw)\\n\\nIf you haven\'t done so already, we encourage you to view the [full release notes](https://github.com/status-im/nimbus-eth2/releases/tag/v1.7.0) for all the gory details.  \\n  \\nThere are a handful of important topics however, that were not covered in the notes that we feel are worth exploring in longer form.\\n\\nIn particular, we\'d like to open up a discussion on **how to improve the security of checkpoint sync**, and another on **how to go about fetching historical data queries in a post EIP-4444 world.**\\n\\n### #[Insecura network (or how to exploit checkpoint sync)](#insecura-network-or-how-to-exploit-checkpoint-sync)\\n\\n> Oh no! A malicious duck has taken over 12000 validator keys from a large custodial operator on the [#eth2](https://twitter.com/hashtag/eth2?src=hash&ref_src=twsrc%5Etfw) pyrmont network, and is now offering a much more master-node oriented vision for the beacon chain, named \\"insecura\\" - what happened here?\\n> \\n> \u2014 Jacek Sieka (@jcksie) [January 21, 2022](https://twitter.com/jcksie/status/1484632785671397379?ref_src=twsrc%5Etfw)\\n\\nOne of the infamous attacks on Proof-of-Stake is the so-called long-range attack, where keys that have been compromised are used to create a new history that honest nodes (who have been offline for a sufficient amount of time) accept as valid.\\n\\n> I don\'t think that\'s right, eg if you have a long-range PoS attack where somebody gathered up keys from 3 years ago to make a new history, everybody knows which chain is legit and which is the dodgy chain, but you have to look at evidence outside the protocol to prove it\\n> \\n> \u2014 Edmund Edgar (@edmundedgar) [July 16, 2019](https://twitter.com/edmundedgar/status/1151042417665159168?ref_src=twsrc%5Etfw)\\n\\nHow could this happen in practice? The long and the short of it is that the beacon chain has a liveness mechanism which exits inactive validators. It\'s possible for a minority player to abuse this mechanism to create a history in which all validators except their own are forced to exit, thereby turning their minority into a majority (on their fork).\\n\\nOnce such a fork exists, the idea is that an attacker could then try to exploit [weak subjectivity](https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity/) to get other nodes to accept it as authentic.\\n\\nFortunately, weak subjectivity, as originally thought out, is quite resistant to such an attack. As long as less than 1/3 of the keys at the time of the fork are compromised, the honest nodes provide a much more plausible history than the attacker\'s: because in contrast to the attacker\'s chain which contains a long period of non-finality during which the honest validators are seeing their stake leaked, the honest nodes have a finalising chain.\\n\\nEven if a single attacker controls more than 2/3 of all keys that were active at the point of the hostile fork, it\'s not clear that they will be able to succeed in convincing the network that their alternative history is correct. In particular, if an honest node isn\'t being [eclipsed](https://www.cs.bu.edu/~goldbe/projects/eclipseEth), it will still likely choose the canonical chain simply because there are more peers serving it.\\n\\nHowever, it turns out that **checkpoint sync changes things quite drastically**. In particular, it\'s not clear whether the above argument still holds. This is quite counter-intuitive. After all, why should passing in a URL rather than a hash make all that much difference to the security assumptions of the network?\\n\\nAs is often the case with security assumptions, the devil lies in the details. What it boils down to is the following: we\'ve subtly shifted the expected behaviour from \xa0\\"getting a block hash from a friend\\" (as articulated in [Vitalik\'s original post on Weak Subjectivity](https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity/)) to \\"trusting a URL from one of a handful of centralised entities\\". This has important consequences.\\n\\nTo paraphrase Jacek here, **checkpoint sync teaches users to pass a single URL from a centralised entity (think Infura or Etherscan) to the beacon node**.\\n\\n**If this URL is compromised (think a security breach at a centralised entity), an attacker can feed the client any state they wish**, and the client will \u201cbelieve\u201d it as long as it passes some basic sanity checks. In particular, the attacker can pass the user a state that has finalised an alternative history (in other words, a different point from where the canonical validators are).\\n\\nIf a node starts syncing from this compromised state, it will end up rejecting any connections to, and blocks from, the honest and correct peers it comes across. It will only be able to accept compromised or dishonest peers, because the attacker\'s chain is finalised at a point which cannot be reconciled with the canonical one.\\n\\nFortunately, Jacek points out that the way this particular issue arises can be detected in a number of ways. In particular, such an attack provides us with several red flags along the way (see the [end of this post](https://ethresear.ch/t/insecura-my-consensus-for-the-pyrmont-network/11833) for a full articulation).\\n\\nDanny Ryan has posted some [further ideas](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice) on how we might go about addressing this problem. Two of the most interesting paths forward include:\\n\\n*   **N participant checkpoint download**: instead of relying on the trustworthiness of one centralised entity, query N entities and check for unanimity\\n    \\n*   **Design a way for the bootnodes to include checkpoints in their published ENRs** -- for example by adding an optional `wsr` (weak-subjectivity-root) field. Note that we can\'t simply rely on querying bootnodes since they are almost always at their peer limits. In other words, we can\'t assume that all clients will be able to maintain a connection to a bootnode.  \\n    \\n\\nWe think it\'s time to move this discussion forward.  \\n  \\n_If you\'d like to get into the weeds here, be sure to check out Jacek\'s [detailed writeup](https://ethresear.ch/t/insecura-my-consensus-for-the-pyrmont-network/11833) on ethresearch. He has actually carried out this attack on Pyrmont, and the post takes you through how this was done._\\n\\n\\n### Era files (a proposed solution to historical data queries)\\n\\nEthereum clients currently store [275 GB](https://twitter.com/lightclients/status/1462576173213372417) of historical data. But this data is not actually needed to validate the chain.\\n\\nIt\'s growing at a rate of around 140 GB per year, and is set to accelerate in a post-merge world. [EIP-4444](https://eips.ethereum.org/EIPS/eip-4444) is a proposal that seeks to address this data bloat by having clients prune data older than 1 year.\\n\\nHowever, some valid concerns have been voiced by the community. In particular, it\'s not clear how much is lost from preventing nodes from serving historical data over the p2p layer (something EIP-4444 explicitly mandates).  \\n  \\n\\n> I used to have the ability to download and validate the full history and state just by setting a flag in geth. With these changes, default nodes will refuse to serve it to me. It may not matter for \u201dmost\u201d, but some of us care about it and do it.\\n> \\n> \u2014 Eric Wall (@ercwl) [December 2, 2021](https://twitter.com/ercwl/status/1466459300096794627?ref_src=twsrc%5Etfw)\\n\\nIn light of these concerns, Jacek\'s recent Era files proposal (see a [draft PR here](https://github.com/status-im/nimbus-eth2/pull/3394)) can be seen as a middle ground of sorts.  \\n\\n> In [#eth](https://twitter.com/hashtag/eth?src=hash&ref_src=twsrc%5Etfw), it\'s widely recognized that having every node sync the full history via p2p is not sustainable, and proposals like rent and EIP-4444 aim to put bounds on what \\"live\\" clients must support. However, it\'s also widely recognized that the historical data is useful! 1/n\\n> \\n> \u2014 Jacek Sieka (@jcksie) [February 15, 2022](https://twitter.com/jcksie/status/1493524432719073284?ref_src=twsrc%5Etfw)\\n\\nWhat exactly is an era file? To borrow Jacek\'s words, an era file is simply a day of blocks followed by the data needed to recreate consensus at that point: **if you have a synced node that knows the current beacon chain head, the data in era files can be used to recreate the fully verified historical state for that time range.**\\n\\nEra files, once created, are easily identifiable, immutable and idempotent: **anyone with a fully synced node can create and/or verify one**, and they can be shared by untrusted third-parties without introducing any new security problems.\\n\\nImportantly, in an era file future the database remains as the source of truth for security purposes -- it stores the latest synced head root which in turn determines where a node \\"starts\\" its consensus participation. The era directory however can be freely shared between nodes / people without any (significant) security implications, assuming the era files are consistent (i.e. not broken).  \\n  \\nIt\'s important to point out that, for now, era files cover only consensus -- in other words, not the full Ethereum state.\\n\\nPost-merge, they\'ll start covering block data, but still won\'t cover the Ethereum state. Supporting the full EIP 4444 world is an open research topic. But focusing on consensus solves an important part of the problem: that is, knowing which state is relevant; this turns the broader problem into a tractable one.\\n\\nIdeas for future improvements include serving the era files via REST: unlike the current implementation which downloads block by block, downloading an era at a time would almost entirely cut out request overhead.\\n\\nOne natural question to ask is how do era files affect the disk storage requirements for nodes?\\n\\nIt turns that the answer depends on the type of node you\'re running, as well as on how the relevant metaparameters are chosen.\\n\\n> today (~1TB) to get \\"mostly equivalent\\" functionality, but more importantly, it stops growing there, by and large, for the \\"normal\\" participant .. light nodes would use a lot less etc..\\n> \\n> \u2014 Jacek Sieka (@jcksie) [February 15, 2022](https://twitter.com/jcksie/status/1493567566178103299?ref_src=twsrc%5Etfw)\\n\\nWe\'d love to hear some thoughtful feedback at this stage. Is this a good idea or not? Where can it be improved? What is it missing?\\n\\n_Additionally, we believe era files (or something similar) have a role to play at the execution (eth1) level. These (torrented) files could then be used to seed [the Portal network](https://our.status.im/nimbus-fluffly/). In fact, the Portal network has recently shifted priority, from working on State network to chain history, mostly due to EIP-4444. See [here](https://snakecharmers.ethereum.org/the-aperture-vol-4/ ) for a general update.  \\n_\\n\\n### A libp2p protocol for light client sync\\n\\nWe\'ve published a [draft implementation](https://github.com/status-im/nimbus-eth2/pull/3341) of our proposed (server side) libp2p protocol for light client sync.\\n\\n> If one had to pick one PR to tell the story why [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) was started as a project, this for sure comes close.. [https://t.co/gnJV4Vnr6m](https://t.co/gnJV4Vnr6m)\\n> \\n> \u2014 Jacek Sieka (@jcksie) [February 15, 2022](https://twitter.com/jcksie/status/1493497173555748865?ref_src=twsrc%5Etfw)\\n\\nLight clients require full nodes to serve additional data so that they can stay in sync with the network. This draft contains a new launch option `--serve-light-client-data` which allows a full node to collect and disseminate the relevant data to light clients.\\n\\nIt\'s an implementation of our [recent contribution](https://github.com/ethereum/consensus-specs/pull/2802) to the consensus specs.\\n\\nFor some context, the Altair specs needed updating, because while they did define structures to aid light client development, they were missing the network protocol definition.\\n\\nIn order to fill this gap, Etan [introduced a libp2p based protocol](https://github.com/ethereum/consensus-specs/pull/2802) to allow light clients to sync to the latest `BeaconBlockHeader` in a trustless and decentralised manner. This builds on top of prior work from both [Hsiao-Wei Wang](https://github.com/ethereum/consensus-specs/pull/2267) and [Jin Huang](https://github.com/ethereum/consensus-specs/pull/2786). You can [keep track of Etan\'s PR here](https://github.com/status-im/nimbus-eth2/pull/3341).\\n\\n_**Useful context:** towards the end of last year, we wrote about [how crucial light clients are to a post-merge Ethereum](https://our.status.im/light-nodes-ethereum-endgame/). In a separate post we also touched on how this will be [an area of focus](https://our.status.im/nimbus-consensus-layer-2122/) for us going forward._\\n\\n### Vouch support\\n\\nLast, but not least, we are now fully compatible with Vouch! A big shout out to Jim who has tirelessly been helping us test, stress and verify compatibility of our [REST API](https://nimbus.guide/rest-api.html) implementation.  \\n\\n> Just released Vouch 1.4.0 with support for [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw). Excited to add another beacon node to the mix.\\n> \\n> \u2014 Jim McDonald (@jgm) [February 21, 2022](https://twitter.com/jgm/status/1495823836704653325?ref_src=twsrc%5Etfw)\\n\\nSince Vouch seems to be becoming a standard of sorts for staking providers, this is great news for client diversity: it\'s now seamless for providers that use Vouch to add Nimbus as an alternative client.  \\n  \\nVouch also allows for other validator clients to run with Nimbus as their beacon node. For example, [Lighthouse has successfully run their VC with a Nimbus BN](https://github.com/sigp/lighthouse/pull/2980#issuecomment-1027392931).\\n\\nWe\'re currently talking with several providers regarding what they can do to add Nimbus to their fleet. If you are a provider, and considering adding Nimbus to yours, please get in touch with us at nimbus@status.im, or alternatively reach out to us [on our discord](https://discord.gg/j3nYBUeEad). We\'re more than happy to answer any questions you may have and provide you with any guidance and support you may need."},{"id":"/nimbus-consensus-layer-2122","metadata":{"permalink":"/nimbus-consensus-layer-2122","source":"@site/posts/nimbus-consensus-layer-2122.md","title":"Nimbus Consensus Layer - past, present, and future","description":"header-image","date":"2022-01-13T10:00:00.000Z","formattedDate":"January 13, 2022","tags":[],"readingTime":6.93,"hasTruncateMarker":true,"authors":[{"name":"Sacha","key":"sacha"}],"frontMatter":{"layout":"post","title":"Nimbus Consensus Layer - past, present, and future","date":"2022-01-13T10:00","authors":"sacha","published":true},"prevItem":{"title":"Nimbus - checkpoint sync, era files, Vouch","permalink":"/nimbus-update-march"},"nextItem":{"title":"The importance of light nodes in Vitalik\'s endgame","permalink":"/light-nodes-ethereum-endgame"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/nimbus-consensus-layer-2122/header.png)\\n\\n_the image above shows 40 of our dependencies purpose built by us for Nimbus and the wider Status ecosystem_\\n\\n> It\'s happening! [#eth2](https://twitter.com/hashtag/eth2?src=hash&ref_src=twsrc%5Etfw) genesis is upon us - stay tuned as we prepare a release with everything necessary to run [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw)!  \\n> \\n> Thanks to researchers, supporters, other client teams and the community - we\'re in this together!\\n> \\n> \u2014 Nimbus (@ethnimbus) [November 24, 2020](https://twitter.com/ethnimbus/status/1331116128870031360?ref_src=twsrc%5Etfw)\\n\\nOne year later, and we\'ve barely had a moment to catch our breath!  \\n  \\nSince the launch of the Beacon chain last December, we\'ve made a ton of improvements and added a bunch of features to our software. The difference between running a Nimbus node today and back then is night and day.\\n\\n### 2021 Highlights\\n\\nSome high-level highlights from the last 12 months include:\\n\\n* 26 [releases](https://github.com/status-im/nimbus-eth2/releases) without any major hiccups.  \\n  \\n* A close to perfect track record for our internal fleet of validators.  \\n  \\n* The first client to release both [doppelganger detection](https://our.status.im/nimbus-update-v1-0-7-release/) and batched attestation verification.  \\n  \\n* Successfully shifting the narrative around [the importance of client diversity](https://our.status.im/the-importance-of-client-diversity/) and [Ethereum\'s green credentials](https://our.status.im/ethereum-is-green/).  \\n  \\n* [Influencing the direction](https://eips.ethereum.org/EIPS/eip-3076) and making [contributions](https://github.com/ethereum/consensus-specs/pull/2746#pullrequestreview-817674843) to both the spec and EIPs.  \\n  \\n* Pushing the limits of what is possible with respect to both CPU and memory usage.\\n  \\nAs we touched on in our [last post](https://our.status.im/light-nodes-ethereum-endgame/), Nimbus\' resource efficiency is not just a nice to have. If decentralisation is [the cost to run a full node](https://twitter.com/jadler0/status/1433985695396282372?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1433985695396282372%7Ctwgr%5E%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Four.status.im%2Fp%2Fdbab5f30-9e0b-49fb-84c7-ef7adb9d9455%2F), then resource efficiency is absolutely [crucial to maintaining a sufficiently robust and decentralised network](https://our.status.im/light-nodes-ethereum-endgame/). This is especially true in a post-merge world in which the community is expected to [keep block producers in check](https://vitalik.ca/general/2021/12/06/endgame.html).\\n\\nTo borrow Dankrad\'s words:\\n\\n> I don\'t care about the absolute number of nodes.  \\n> I care about the amount of transaction value that is fully secured. That means the user is either running a full node or a fraud proof-protected light client.\\n> \\n> \u2014 Dankrad Feist (@dankrad) [July 14, 2021](https://twitter.com/dankrad/status/1415424096024858624?ref_src=twsrc%5Etfw)\\n\\nToday, Nimbus is able to run performantly on a single core of a Raspberry Pi 4 while also running Geth, RocketPool and monitoring software (Prometheus + Grafana) in the background. We expect this to keep holding true post merge.\\n\\n> We are on it, [@go\\\\_ethereum](https://twitter.com/go_ethereum?ref_src=twsrc%5Etfw) Geth + [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) in the same [@Raspberry\\\\_Pi](https://twitter.com/Raspberry_Pi?ref_src=twsrc%5Etfw). [https://t.co/s2lg573Njh](https://t.co/s2lg573Njh)\\n> \\n> \u2014 Ethereum on ARM \ud83e\udd87\ud83d\udd0a (@EthereumOnARM) [June 22, 2021](https://twitter.com/EthereumOnARM/status/1407339958046765061?ref_src=twsrc%5Etfw)\\n\\nPerhaps one final thing worth mentioning here is that our language of choice, Nim, has required us to build out nearly all the [libraries](https://nimbus.team/docs/libraries.html) we rely on ourselves. In the light of recent NPM and Pypi registry attacks, we believe this to be a key strength of ours relative to other clients.  \\n  \\nWe have very few external dependencies. And these dependencies are all fuzzed, audited, formally verified, \xa0or have similar rock solid guarantees.\\n\\n> Curious which libraries Nimbus depends on? \\\\`make deps\\\\` shows the full transitive list with the exact version, including the [@nim\\\\_lang](https://twitter.com/nim_lang?ref_src=twsrc%5Etfw) compiler - there is 61 of them right now, counting several that are used only for testing - 40 were purpose-built by [@ethstatus](https://twitter.com/ethstatus?ref_src=twsrc%5Etfw)! [pic.twitter.com/L407vmQKZK](https://t.co/L407vmQKZK)\\n> \\n> \u2014 Nimbus (@ethnimbus) [January 10, 2022](https://twitter.com/ethnimbus/status/1480500108810674176?ref_src=twsrc%5Etfw)\\n\\n\\n### Icing on the cake\\n\\nHaving thought deeply about, and written extensively on [the importance of trustless staking pools](https://medium.com/dappnode/guardians-of-ethereum-a-validator-dao-proposal-d82e76231b45), the icing on the cake for us last year was, without a doubt, the launch of Rocket Pool.\\n\\nAfter everything the team has been through, notably the [drama](https://medium.com/rocket-pool/the-merge-0x02-mev-and-the-future-of-the-protocol-c7451337ec40) around `0x02`, it was truly wonderful to see their vision of a trustless and community owned staking pool start to take shape.\\n\\nWe were especially happy to see that, by some estimates, Nimbus is the second most popular Rocket Pool client.\\n\\n> 218 [@Rocket\\\\_Pool](https://twitter.com/Rocket_Pool?ref_src=twsrc%5Etfw) proposals, four weeks in: [pic.twitter.com/HrLZrjCWWC](https://t.co/HrLZrjCWWC)\\n> \\n> \u2014 superphiz.eth \ud83e\udd87\ud83d\udd0a\ud83d\udc3c (@superphiz) [December 6, 2021](https://twitter.com/superphiz/status/1467978840278503429?ref_src=twsrc%5Etfw)\\n\\nThank you Joe Clapis for everything you\'ve done to red-pill the community into using Nimbus :)\\n\\n### Zooming in on last quarter\\n\\nIn case you haven\'t kept up with our [latest releases](https://github.com/status-im/nimbus-eth2/releases), arguably the three most important features shipped last quarter were:\\n\\n* Support for the `web3signer` protocol (currently in BETA)\\n  \\n* A feature complete `rest` API (still ironing out a few issues)\\n  \\n* A `--num-threads` option which allows Nimbus to take advantage of multiple CPU cores\\n  \\n`v1.5.5` alone saw three significant optimisations worth highlighting here:\\n\\n* A 6x speed-up in epoch processing\\n  \\n* A 2x speed up in Altair block processing\\n  \\n* A 12% reduction in outgoing GossipSub traffic (bandwidth reduction).\\n  \\n> A calm-after-the-altair-storm release with lots of polish across the board - big drop in outgoing network traffic thanks to an elegant libp2p optimization, more flexibility in the REST interface allows you to use Nimbus with a growing amount of 3rd party tools, web3signer.. [https://t.co/RTerT29ijA](https://t.co/RTerT29ijA)\\n> \\n> \u2014 Jacek Sieka (@jcksie) [December 6, 2021](https://twitter.com/jcksie/status/1467938248936804356?ref_src=twsrc%5Etfw)\\n\\nBoth `web3signer` support and the `rest` API pave the way for wider adoption of Nimbus. `web3signer` by allowing for staking pools and other providers with a custom key handling strategy to use Nimbus. And the `rest` API by allowing for third-party validator clients such as [Vouch](https://www.attestant.io/posts/introducing-vouch/) (or any other validator client for that matter) to use Nimbus as their beacon node.\\n\\nSpecial thanks to Jim Mcdonald (@jgm) for helping us test the REST server: It is in large part thanks to your testing that we managed to get to the finish line!\\n\\n### Going forward\\n\\nThere is so much to look forward to in 2022. Here\'s a quick overview of our priorities:\\n\\n* **The merge, then sharding**: the main focus here is on the stellar and timely execution of the [merge](https://github.com/ethereum/consensus-specs/tree/dev/specs/merge) followed by the [sharding](https://github.com/ethereum/consensus-specs/blob/dev/specs/sharding/beacon-chain.md) specs.\\n  \\n* **Wider adoption**: we have a new business development unit (welcome [Kausha](https://twitter.com/liftlines)l!) devoted to increasing adoption. The initial focus will be on providing support for staking pools and providers who wish to adopt Nimbus ( a number of which have already committed to running Nimbus this year).\\n  \\n* **Diversity++:** this will mainly involve implementing all standards which seek to promote client diversity \xa0(e.g. the development of cross-client UIs, migration tools, and the [SSV](https://ssv.network/) network).\\n  \\n* **The great rebranding**: we want people to realise at a glance that Nimbus is great for far more than just resource-restricted devices. And, in particular, that there are important advantages to using it for enterprise grade infrastructure. This requires rethinking our branding and how we talk about ourselves.\\n  \\n* **Privacy**: as part of Status, caring about privacy is in our DNA. We plan on exploring how we can leverage our work on [Waku](https://rfc.vac.dev/spec/10/) in order to [bring more privacy to validators at the networking layer](https://github.com/libp2p/specs/issues/374).\\n  \\n* **A Nimbus focused UI**: we are committing serious resources towards a Nimbus UI which will be an integral part of the Status product roadmap moving forward. Our focus here is on user-friendly approaches for creating, managing, and monitoring validators (no CLI experience needed).\\n  \\nThis year will also see us increasingly focused on lowering the technical barriers to running a full node (both consensus and execution) as well as pushing forward with our [light client implementation](https://github.com/etan-status/nimbus-eth2/compare/merkle-multiproof...etan-status:lightclient-api) (keep track of our progress [here](https://github.com/status-im/nimbus-eth2/issues/2337#issuecomment-967153855)).\\n\\nAs we mentioned in our [execution layer recap](https://our.status.im/nimbus-execution-layer/), one of our main design goals is to make it as easy as possible for our consensus and execution clients to be bundled into a single piece of software. With the Nimbus UI, you\'ll be able \xa0to manage and monitor your node straight from the Status Desktop app.\\n\\n> I can\'t wait to run Nimbus straight from Status Desktop [#hyped](https://twitter.com/hashtag/hyped?src=hash&ref_src=twsrc%5Etfw)\\n> \\n> \u2014 Jarrad Hope (@0xc1c4da) [August 12, 2020](https://twitter.com/0xc1c4da/status/1293473249347555334?ref_src=twsrc%5Etfw)\\n\\n[Complementary to this vision](https://our.status.im/light-nodes-ethereum-endgame/) (and part of our longer-term UI roadmap) is an embedded light client running on your mobile phone.\\n\\n\\n### More thank yous\\n\\nWe want to end by saying a big thank you to the Ethereum Foundation for the unbelievably generous incentive program they [announced](https://blog.ethereum.org/2021/12/13/client-incentive-program/) towards the end of last year. We are truly humbled to be valued by you in this way.\\n\\nA big thank you to all the node runners using Nimbus, without you our work would be, quite frankly, meaningless.\\n\\nAnd, last but by no means least, a big thank you to all our [Gitcoin supporters](https://gitcoin.co/grants/137/nimbus): even more important than the financial, is the moral support; the appreciation we feel from every single one of you, each GR round, keeps our spirits high when the going feels tough.  \\n  \\nWe wish you all the very best of luck this coming year."},{"id":"/light-nodes-ethereum-endgame","metadata":{"permalink":"/light-nodes-ethereum-endgame","source":"@site/posts/light-nodes-ethereum-endgame.md","title":"The importance of light nodes in Vitalik\'s endgame","description":"Ethereum can support both full nodes and light clients, it contains a peer to peer layer which allows nodes to send messages to each other.","date":"2021-12-10T10:00:00.000Z","formattedDate":"December 10, 2021","tags":[],"readingTime":4.5,"hasTruncateMarker":true,"authors":[{"name":"Sacha","key":"sacha"}],"frontMatter":{"layout":"post","title":"The importance of light nodes in Vitalik\'s endgame","description":"Ethereum can support both full nodes and light clients, it contains a peer to peer layer which allows nodes to send messages to each other.","date":"2021-12-10T10:00","authors":"sacha","published":true},"prevItem":{"title":"Nimbus Consensus Layer - past, present, and future","permalink":"/nimbus-consensus-layer-2122"},"nextItem":{"title":"Nimbus + Nethermind - Kintsugi tutorial","permalink":"/kintsugi-merge"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/light-nodes-ethereum-endgame/header.png)\\n\\n\\n_image courtesy of [Vitalik\'s endgame post](https://vitalik.ca/general/2021/12/06/endgame.html)_\\n\\n### Preface\\n\\nEthereum can support both full nodes and light clients, it contains a peer to peer layer which allows nodes to send messages to each other. While Ethereum\'s current architecture is not particularly well-suited to light clients, the beacon chain architecture is. This means that post-merge, they will have an important role to play. A light client is a cheaper alternative to a full node (from a bandwidth and resource consumption perspective) since it only downloads the header from each block and trusts the full nodes to check that the state transitions are correct (in other words, a light client trusts the full nodes it is peered with to verify that the block producer hasn\'t tried to print new coins, \xa0spend coins from an address for which they don\u2019t have the private key, or make larger blocks than the consensus rules allow them to do). This does beg the question however: under what assumptions are light clients able to protect themselves from malicious block producers?\\n\\n### Relaxing assumptions\\n\\nIn [the endgame](https://vitalik.ca/general/2021/12/06/endgame.html), we expect that most individuals will transact on Ethereum using light clients without even knowing it. For example, the plan has always been for the [Status mobile app](https://status.im/get/) to come integrated with a light version of Nimbus.  \\n  \\nSince light clients typically only download block headers, and don\u2019t verify transactions themselves, we are used to thinking of them as having weak security guarantees compared to full nodes: under the conventional model, they are forced to rely on an honest majority assumption (which means they must assume the chain is valid by default).  \\n  \\nHowever, it turns out that we can do significantly better than that.\\n\\nThanks to the magic of [fraud and data availability proofs](https://arxiv.org/abs/1809.09044), we can relax the honest majority assumption, and make a 1/N honesty assumption instead. Practically speaking this means a light client only needs to be peered with a _single_ honest full node in order to inherit almost the same security guarantees. In the rest of this post we will refer to this genre of light client as a _light node_.\\n\\n### A light sketch\\n\\nWhile we won\'t get into the [gory details](https://dankradfeist.de/ethereum/2019/12/20/data-availability-checks.html) here, here\'s a light sketch of how this works.\\n\\nWhen a light node receives a block header, it [probabilistically samples](https://coinmarketcap.com/alexandria/article/what-is-data-availability) enough shares from the [Merkle tree](https://blog.iden3.io/merkle-trees-visual-introduction.html) that the Merkle root represents to convince itself that the entire tree is indeed available for full nodes to verify (in other words, the light node is able to verify that the block producer has not withheld any data from the network).\\n\\nAt the same time, it listens for fraud proofs \u2013 a small, and quickly verifiable proof that a specific transaction in a block is invalid \u2013 from the nodes it is peered with. A valid fraud proof convinces that light node that the Merkle root in the block header is in fact incorrect. In the absence of a valid fraud proof, it goes ahead and accepts the block header as truthful.\\n\\n### What does this tell us?\\n\\nThe key takeaway here is that **as long as a light node is peered with at least one honest full node, it has practically the same security guarantees as that full node** (since it can expect to receive a fraud proof from it if the block header it receives is incorrect).\\n\\nA more subtle insight to be gleaned here is the following: **light nodes can only offer the same protection as full nodes if enough people run both light and full nodes.** This is true because you need enough light nodes in the network to collectively recover blocks, and enough honest full nodes to give every light client a good chance of being connected to at least one of them.\\n\\nIt follows that to ensure a resilient network, one in which individuals transacting on Ethereum can detect if/when block producers are trying to [change the rules](https://dankradfeist.de/ethereum/2021/05/20/what-everyone-gets-wrong-about-51percent-attacks.html) on them, we need to do two things:\\n\\n1. Make it dead simple to run a light node on mobile devices (and other resource-restricted devices).\\n    \\n2. Make it dead simple to run a full node on low-power commodity hardware (in particular this includes Raspberry Pis and everyday laptops).\\n\\nThese two things become **especially important in a world in which block production is centralised** (the [likely endgame](https://vitalik.ca/general/2021/12/06/endgame.html) we are heading for).\\n\\n### A means to self-sovereignty\\n\\nTo fork [the words](https://twitter.com/jadler0/status/1433985695396282372?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1433985695396282372%7Ctwgr%5E%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Four.status.im%2Fp%2Fdbab5f30-9e0b-49fb-84c7-ef7adb9d9455%2F) of John Adler: thanks to fraud proofs and data availability sampling, we can think of decentralisation as some function of the cost to run a full node and the cost to run a light node. Not because running either is anything special, but because they are a means to an end: self sovereignty\\\\*.  \\n  \\n\\\\*Self sovereignty in this context means that we, the community, are able to detect when block producers try to change the rules that we all agree on.\\n\\n### Resources\\n\\n* [Beacon Chain Light Client Classification](https://ethresear.ch/t/beacon-chain-light-client-classification/11061)\\n\\n* [Beacon Chain Light Client Networking](https://ethresear.ch/t/beacon-chain-light-client-networking/11063)\\n\\n* [Beacon Chain Light Client Design Doc](https://notes.ethereum.org/@ralexstokes/S1RSe1JlF)\\n\\n* [Bootstrapping the Beacon Chain Light Client Ecosystem](https://notes.ethereum.org/@ralexstokes/S1RSe1JlF)\\n\\n* [Altair: Minimum Light Client Spec](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.md)\\n\\n* [Lodestar Light Client Demo](https://github.com/ChainSafe/eth2-light-client-demo/tree/dapplion/update-to-prater)\\n\\n* [Nimbus Light Client Syncing Implementation](https://github.com/status-im/nimbus-eth2/issues/2337)\\n\\n* [Experimental Nimbus Light Client Server](https://github.com/etan-status/nimbus-eth2/compare/merkle-multiproof...etan-status:lightclient-api)  \\n    (expand the commit description ... for instructions on how to play with it)\\n\\n* [Run a Nimbus Beacon Node](https://nimbus.guide/quick-start.html)  \\n\\n_Thanks to Barnab\xe9 Monnot and \u0218tefan Talpalaru for reading drafts of this._"},{"id":"/kintsugi-merge","metadata":{"permalink":"/kintsugi-merge","source":"@site/posts/kintsugi-merge.md","title":"Nimbus + Nethermind - Kintsugi tutorial","description":"Ethereum can support both full nodes and light clients, it contains a peer to peer layer which allows nodes to send messages to each other.","date":"2021-11-23T10:00:00.000Z","formattedDate":"November 23, 2021","tags":[],"readingTime":5.505,"hasTruncateMarker":true,"authors":[{"name":"Sacha","key":"sacha"}],"frontMatter":{"layout":"post","title":"Nimbus + Nethermind - Kintsugi tutorial","description":"Ethereum can support both full nodes and light clients, it contains a peer to peer layer which allows nodes to send messages to each other.","date":"2021-11-23T10:00","authors":"sacha","published":true},"prevItem":{"title":"The importance of light nodes in Vitalik\'s endgame","permalink":"/light-nodes-ethereum-endgame"},"nextItem":{"title":"Nimbus - Execution Layer","permalink":"/nimbus-execution-layer"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/kintsugi-merge/header.png)\\n\\n_Diagram courtesy of Mikhail Kalinin\'s [Engine API design space](https://hackmd.io/@n0ble/consensus_api_design_space) document. Note that this diagram dates from the Amphora era, and so is not strictly accurate. Nevertheless the general communication flow between consensus and execution for Kintsugi is the same._\\n\\n> Kintsugi, also known as kintsukuroi, is the Japanese art of repairing broken pottery by mending the areas of breakage with lacquer dusted or mixed with powdered gold. [pic.twitter.com/M9BiJfLqLb](https://t.co/M9BiJfLqLb)\\n> \\n> \u2014 Monica Zeng (@monicazng) [November 27, 2020](https://twitter.com/monicazng/status/1332314234265477121?ref_src=twsrc%5Etfw)\\n\\nThe Merge November sprint \u2013 _Kintsugi -_ has kicked off.  \\n  \\nKintsugi [specs](http://spec.merge.wiki/) and [milestones](https://notes.ethereum.org/@djrtwo/kintsugi-milestones) were released earlier this month. And we, along with the other client teams, have started participating in the weekly rolling merge devnets in preparation for the more open and persistent testnet planned for early December.\\n\\n### #[Kintsugi spec: quick recap](#kintsugi-spec-quick-recap)\\n\\nKintsugi incorporates all of the learnings (along with some minor adjustments) from the previous interop, [Amphora](https://blog.ethereum.org/2021/10/15/amphora-merge-milestone/).  \\n  \\nAt a high-level, the scope of work on updating consensus layer client software to Kintsugi specification is as follows:\\n\\n* Implement the new version of consensus-spec and pass all consensus-spec tests\\n\\n* Implement the new version of [Engine API](https://github.com/ethereum/execution-apis/blob/89070c4d6f2fbe125a906f0cca1fedda84b8a2a6/src/engine/specification.md) method calls\\n\\n* Implement or update already existing implementation of the [optimistic sync](https://github.com/sigp/lighthouse/issues/2691)\\n\\nOn the execution layer side, it looks like this:\\n\\n* Implement the new version of [EIP-3675](https://eips.ethereum.org/EIPS/eip-3675)\\n\\n* Implement [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399)\\n\\n* Implement the new version of [Engine API](https://github.com/ethereum/execution-apis/blob/89070c4d6f2fbe125a906f0cca1fedda84b8a2a6/src/engine/specification.md) server\\n\\n\\n> Support Ethereum ecosystem client diversity!  \\n>   \\n> Consider running:  \\n>   \\n> \\\\* Nethermind [https://t.co/8A3bkliGAy](https://t.co/8A3bkliGAy) or Besu [https://t.co/RNPpIXrVX3](https://t.co/RNPpIXrVX3) for an ethereum mainnet node  \\n>   \\n> \\\\* Nimbus [https://t.co/8LWdsGEuKi](https://t.co/8LWdsGEuKi) or Teku [https://t.co/mXUWTxKlPu](https://t.co/mXUWTxKlPu) if you\'re on the eth2 Medalla testnet\\n> \\n> \u2014 vitalik.eth (@VitalikButerin) [August 11, 2020](https://twitter.com/VitalikButerin/status/1293317390613110785?ref_src=twsrc%5Etfw)\\n\\nIn line with our commitment to client diversity, this tutorial will tackle how to run a Nimbus local testnet with Nethermind (if you wish to do the same with Geth, see [this document](https://github.com/status-im/nimbus-eth2/blob/unstable/docs/interop_merge.md)).\\n\\nWe assume you have a working and up to date installation of Nimbus - if this is not the case, please start by following the instructions [here](https://nimbus.guide/quick-start.html).\\n\\n### 1- Install dotnet\\n\\n[Nethermind](https://docs.nethermind.io/nethermind/) is a .NET Core-based Ethereum client, so the first step is to download dotnet.\\n\\n```\\nhttps://dotnet.microsoft.com/download\\n```\\n\\n_Note that you may need to download a specific version of dotnet to be able to build the Nethermind kintsugi branch. In this guide we use version `5.0.12`. By the time you read this guide you may need version `6.0`._\\n\\n### 2- Build Nethermind\\n\\nFrom the command line, run the following:\\n\\n```\\ngit clone https://github.com/NethermindEth/nethermind.git --recursive -b themerge_kintsugi\\ncd src/Nethermind\\ndotnet build Nethermind.sln -c Release\\n# if src/Nethermind/Nethermind.Runner/bin/Release/net5.0/plugins has no Nethermind.Merge.Plugin.dll plugin then you may need to run the build again\\ndotnet build Nethermind.sln -c Release\\n```\\n\\n### 3- Run Nethermind\\n\\nOnce Nethermind has been built, you are ready to run it:\\n\\n```\\ncd Nethermind.Runner\\nrm -rf bin/Release/net5.0/nethermind_db\\ndotnet run -c Release -- --config themerge_kintsugi_m2 --Merge.TerminalTotalDifficulty 0\\n```\\n\\n### 4- Checkout the Nimbus Kintsugi branch\\n\\nWith Nethermind running, open a separate terminal window. Change into the `nimbus-eth2` directory and run:\\n\\n```\\ngit checkout kintsugi\\ngit pull\\nmake update\\n```\\n\\n### 5- Launch local testnet\\n\\nStill in `nimbus-eth2`, run:\\n\\n```\\n./scripts/launch_local_testnet.sh --preset minimal --nodes 4 --disable-htop --stop-at-epoch 7 -- --verify-finalization --discv5:no\\n```\\n\\nThis will create a 4-node local testnet with 128 validators that will exist for 7 epochs. Feel free to try out different parameters if you so wish.\\n\\n### 6- Check Nimbus\' output\\n\\nIf all is working correctly, the Nimbus console output should look something like:\\n\\n```\\nnimbus-eth2$ N=0; while ./scripts/launch_local_testnet.sh --preset minimal --nodes 4 --disable-htop --stop-at-epoch 8 -- --verify-finalization --discv5:no; do N=$((N+1)); echo \\"That was run #${N}\\"; sleep 67; done\\nBuilding: build/nimbus_beacon_node\\nBuilding: build/nimbus_signing_process\\nBuilding: build/deposit_contract\\nBuild completed successfully: build/nimbus_signing_process\\nBuild completed successfully: build/deposit_contract\\nBuild completed successfully: build/nimbus_beacon_node\\nNOT 2021-11-17 15:40:11.894+01:00 Generating deposits                        tid=966934 file=keystore_management.nim:562 totalNewValidators=128 validatorsDir=local_testnet_data/validators secretsDir=local_testnet_data/secrets\\nNOT 2021-11-17 15:40:51.434+01:00 Deposit data written                       tid=966934 file=deposit_contract.nim:222 filename=local_testnet_data/deposits.json\\nWrote local_testnet_data/genesis.ssz\\nWRN 2021-11-17 15:40:51.443+01:00 Using insecure password to lock networking key key_path=local_testnet_data/network_key.json\\nINF 2021-11-17 15:40:52.184+01:00 New network key storage was created        topics=\\"networking\\" key_path=local_testnet_data/network_key.json network_public_key=08021221029b0d9c63dc15335b6f1f73dc359a0bda88a84cc7e0346f12e64084673a35a915\\nWrote local_testnet_data/bootstrap_nodes.txt\\nWrote local_testnet_data/config.yaml:\\nDEPOSIT_NETWORK_ID: 1\\nPRESET_BASE: minimal\\nMIN_GENESIS_ACTIVE_VALIDATOR_COUNT: 128\\nMIN_GENESIS_TIME: 0\\nGENESIS_DELAY: 10\\nDEPOSIT_CONTRACT_ADDRESS: 0x0000000000000000000000000000000000000000\\nETH1_FOLLOW_DISTANCE: 1\\nALTAIR_FORK_EPOCH: 1\\nMERGE_FORK_EPOCH: 2\\nTERMINAL_TOTAL_DIFFICULTY: 0\\nThat was run #1\\n```\\n\\nIf you\'re using macOS you may also see a bunch of warnings that look like\\n\\n```\\nwarning: (x86_64)  could not find object file symbol for symbol _br_rsa_pkcs1_sig_unpad.pad1\\n```\\n\\nYou can safely ignore these.\\n\\n### 7- Check Nethermind\'s output\\n\\nOn the Nethermind side, you should pay particular attention to the following JSON RPC calls: `engine_forkchoiceUpdatedV1`, `engine_getPayloadV1`, `engine_executePayloadV1` \u2013 these document the consensus calling the [engine api](https://github.com/ethereum/execution-apis/blob/v1.0.0-alpha.4/src/engine/specification.md) for a valuable payload.\\n\\nTo elaborate a little, in a post-merge beacon chain, a consensus layer client needs to call two functions from the execution layer client in order to prepare a block:\\n\\n* `engine_forkchoiceUpdatedV1`, which returns the `status` (\\\\`SUCCESS\\\\` or \\\\`SYNCING\\\\`) and a `payloadId`.\\n\\n* `engine_getPayloadV1` which accepts a `payloadId`.\\n\\nThe ultimate goal of these two calls is to allow for an execution (eth1) block to be included in a consensus (eth2) block.\\n\\n_More formally**,** `engine_executePayloadV1` verifies the payload according to the execution environment rule set ([EIP-3675](https://eips.ethereum.org/EIPS/eip-3675#specification)) and returns the status of the verification_\\n\\n`forkchoiceUpdatedV1` first propagates the change in the fork choice to the execution client (for example, the head of the chain and the finalized block must be updated according to the given data) before initiating the preparation of the payload \xa0if it is needed; this allows the consensus client to be able to give the execution client some time to prepare the payload (i.e., find the best set of transactions it can from the mempool) before the `getPayloadV1` call is made.\\n\\nTo borrow an explanation from Danny Ryan, intuitively the call semantics are:\\n\\n* \\"update your fork choice\\" (no payload build requested)\\n\\n* \\"update your fork choice and start building something valuable on top of it!\\" (payload build requested)\\n\\nThe latter only happens when you need to propose a block.\\n\\n### How do we know that the merge has happened?\\n\\nThe first `engine_executePayloadV1` method call that communicates a valid payload to the execution client initiates the Merge transition.\\n\\nThen the first `[POS_FORKCHOICE_UPDATED](https://eips.ethereum.org/EIPS/eip-3675#specification)` event (in the form of a `engine_forkchoiceUpdatedV1` method call) that finalises the first communicated payload finishes the transition.\\n\\nAfter the Merge transition is finalised, the Merge can be considered as having happened.\\n\\nThis tutorial is adapted from [Dustin Brody\'s original](https://github.com/status-im/nimbus-eth2/blob/unstable/docs/neth-m2-nimbus.md) (Dustin has been leading the charge on the Merge interop front at Nimbus). If you get stuck anywhere, or have any questions at all please don\'t hesitate to get in touch with us on our [discord](https://discord.gg/9SSF5tAd). You can keep track of our Kintsugi progress [here](https://github.com/status-im/nimbus-eth2/pull/3093), and Nethermind\'s progress [here](https://github.com/NethermindEth/nethermind/pull/3597)."},{"id":"/nimbus-execution-layer","metadata":{"permalink":"/nimbus-execution-layer","source":"@site/posts/nimbus-execution-layer.md","title":"Nimbus - Execution Layer","description":"It is a little known secret that, in addition to our consensus layer (eth2) client we are building out an execution layer (eth1) client - with the objective that it should be ready for the merge.","date":"2021-11-13T10:00:00.000Z","formattedDate":"November 13, 2021","tags":[],"readingTime":4.665,"hasTruncateMarker":true,"authors":[{"name":"Sacha","key":"sacha"}],"frontMatter":{"layout":"post","title":"Nimbus - Execution Layer","description":"It is a little known secret that, in addition to our consensus layer (eth2) client we are building out an execution layer (eth1) client - with the objective that it should be ready for the merge.","date":"2021-11-13T10:00","authors":"sacha","published":true},"prevItem":{"title":"Nimbus + Nethermind - Kintsugi tutorial","permalink":"/kintsugi-merge"},"nextItem":{"title":"Nimbus update - Pre-merge interop!","permalink":"/nimbus-update-pre-merge-devnets"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/nimbus-execution-layer/header.png)\\n\\nIt is a little known secret that, in addition to our consensus layer (eth2) client we are building out an execution layer (eth1) client - with the objective that it should be ready for the merge.\\n\\nWhy is this important? One topical reason is client diversity.\\n\\n> 1/ A diverse execution-layer client ecosystem is at the heart of all that we\u2019re building together.  \\n> \\n> Today, we\'re excited to announce that [@compoundgrants](https://twitter.com/compoundgrants?ref_src=twsrc%5Etfw), [@krakenfx](https://twitter.com/krakenfx?ref_src=twsrc%5Etfw), [@LidoFinance](https://twitter.com/LidoFinance?ref_src=twsrc%5Etfw), [@synthetix\\\\_io](https://twitter.com/synthetix_io?ref_src=twsrc%5Etfw), [@graphprotocol](https://twitter.com/graphprotocol?ref_src=twsrc%5Etfw) & [@Uniswap](https://twitter.com/Uniswap?ref_src=twsrc%5Etfw) are donating $250K each to support [#Ethereum](https://twitter.com/hashtag/Ethereum?src=hash&ref_src=twsrc%5Etfw) client teams.\\n> \\n> \u2014 Ethereum (@ethereum) [August 24, 2021](https://twitter.com/ethereum/status/1430124634104545288?ref_src=twsrc%5Etfw)\\n\\nTo put it simply, the more functional and performant clients we have on both layers (consensus + execution), the better and more resilient Ethereum stands to be.\\n\\n> \\\\* we already have the most client diversity out of any chain  \\n> \\n> \\\\* but we can do better. the beacon chain was built to incentivise this, and so stakers are pushed to run minority clients  \\n> \\n> \\\\* by having ensuring that no one client is dominant, we harden ourselves against bugs\\n> \\n> \u2014 carlbeek.eth (@CarlBeek) [October 15, 2021](https://twitter.com/CarlBeek/status/1449126854498078722?ref_src=twsrc%5Etfw)\\n\\nWhile **client diversity is crucial to a resilient Ethereum**, it alone would not warrant such a huge engineering effort on our part.\\n\\nOur high level vision, and the main reason we\'re rolling our own execution layer client, is for **easy and seamless integration with Status** - both desktop and mobile.\\n\\n> I can\'t wait to run Nimbus straight from Status Desktop [#hyped](https://twitter.com/hashtag/hyped?src=hash&ref_src=twsrc%5Etfw)\\n> \\n> \u2014 Jarrad Hope | @ethstatus (@0xc1c4da) [August 12, 2020](https://twitter.com/0xc1c4da/status/1293473249347555334?ref_src=twsrc%5Etfw)\\n\\nSuch an integration requires a custom, embeddable, and ultra-efficient Ethereum client - across both execution and consensus layer environments.\\n\\n### Relationship with Fluffy\\n\\nTo achieve the above requires us to optimize resource consumption in novel ways. At the execution layer, we aim to offer **a unique combination of lower space usage and faster sync.**\\n\\nOur method of syncing, which we call beam-ish sync, will allow nodes to participate in the network early, while data sync continues in the background - this behaviour is similar to [Fluffy](https://our.status.im/nimbus-fluffly/) (our [Portal Network](https://www.ethportal.net/) light client) and our work there will be re-used here - the idea is that we\'ll eventually integrate Fluffy into our execution client.\\n\\nIn addition to integating Fluffy, one of our main design goals is to make it as easy as possible for our consensus and execution clients to be bundled into a single piece of software; this will drastically improve the UX of running a post-merge client, making it very similar to running a pre-merge PoW client today.\\n\\nThis ties into our overarching vision: to significantly lower the barrier to running both full nodes and light clients, and in doing so help make Ethereum as accessible and decentralised as possible.\\n\\n> Decentralization is the cost to run a full node. Not because running a full node is inherently anything special, but because it\'s a means to an end: self-soverignty. Being able to detect when block producers try to change the rules that we the community all agree on.\\n> \\n> \u2014 John Adler | \u2728\u26fd (@jadler0) [September 4, 2021](https://twitter.com/jadler0/status/1433985695396282372?ref_src=twsrc%5Etfw)\\n\\n### Recent progress\\n\\nSome highlights from the past 6 months include:\\n\\n* Significantly expanded the team: meet [Jamie](https://github.com/jlokier) and [Jordan](https://github.com/mjfh)\\n  \\n* Renewed funding from the EF to accelerate \xa0development\\n  \\n* Completed Berlin and London fork compatibility (EIP-1559): we now pass nearly all the EF Hive testsuite, and 100% of contract execution tests (47,951 tests)\\n  \\n* New GraphQL and WebSocket APIs, complementing JSON-RPC\\n  \\n* EVMC compatibility, supporting third-party optimised EVM plugins. Up to 100x memory saving during contract executions. Asynchronous EVM to execute many contracts in parallel (while they wait for data from the network)\\n  \\n* Proof-of-authority validation for the Goerli test network. Updated network protocols, to work with the latest eth/65-66 and snap/1 protocols\\n  \\n* A prototype new mechanism for state sync which combines what have been called Fast sync, Snap sync and Beam sync in a self-tuning way, and allows the user to participate in the network (read accounts, run transactions etc.) while sync is still in progress\\n  \\n* A working transaction pool\\n  \\n\\n> Spotted in the [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) discord today.. [pic.twitter.com/1Ffqgd1iDz](https://t.co/1Ffqgd1iDz)\\n> \\n> \u2014 Jacek Sieka (@jcksie) [October 8, 2021](https://twitter.com/jcksie/status/1446399794243592200?ref_src=twsrc%5Etfw)\\n\\nWahay! I can confirm there have been no other issues (consensus, networking) syncing up to the head block of Goerli, and I can finally answer the question: \\"What happens if you just run `nimbus --goerli` today?\\"\\n\\n### Still in progress\\n\\nWhile we\'ve made significant progress on many fronts, we still have our work cut out for us in the run up to the merge. As it stands, we are currently working on:\\n\\n* A significant redesign of the storage database to use less disk space and run faster\\n  \\n* The ability to post a transaction for one\'s own account\\n  \\n* Implementing [EIP-3675](https://eips.ethereum.org/EIPS/eip-3675) (aka The Merge)\\n  \\n\\n> In a month, we would like to launch a larger Merge devnet with better client distribution, once development stabilizes more.  \\n> \\n> 4/5\\n> \\n> \u2014 proto.eth \ud83d\ude82 \ud83e\udd87 \ud83d\udd0a (@protolambda) [October 11, 2021](https://twitter.com/protolambda/status/1447595072543920132?ref_src=twsrc%5Etfw)\\n\\n### Stay updated\\n\\nThe plan for this month is to participate in the rolling merge devnets \xa0- one per week - before the more persistent testnet planned for the first week of December. We are working as hard as we can to try to have our execution layer client ready in time. Our immediate goal however is to pass the merge interop milestones in local tests.\\n\\nIf you have any questions or would like to stay updated on our progress, please join our [discord](https://discord.gg/7G5GCMRZ) and or sign up to our [newsletter](http://subscribe.nimbus.team/)."},{"id":"/nimbus-update-pre-merge-devnets","metadata":{"permalink":"/nimbus-update-pre-merge-devnets","source":"@site/posts/nimbus-update-pre-merge-devnets.md","title":"Nimbus update - Pre-merge interop!","description":"It is a little known secret that, in addition to our consensus layer (eth2) client we are building out an execution layer (eth1) client - with the objective that it should be ready for the merge.","date":"2021-10-02T10:00:00.000Z","formattedDate":"October 2, 2021","tags":[],"readingTime":4.43,"hasTruncateMarker":true,"authors":[{"name":"Sacha","key":"sacha"}],"frontMatter":{"layout":"post","title":"Nimbus update - Pre-merge interop!","description":"It is a little known secret that, in addition to our consensus layer (eth2) client we are building out an execution layer (eth1) client - with the objective that it should be ready for the merge.","date":"2021-10-02T10:00","authors":"sacha","published":true},"prevItem":{"title":"Nimbus - Execution Layer","permalink":"/nimbus-execution-layer"}},"content":"\x3c!-- truncate --\x3e\\n\\n![header-image](/posts/nimbus-update-pre-merge-devnets/header.png)\\n\\nIn the words of Danny Ryan, Altair is here and the Merge is coming!\\n\\n> Finalized no. 29[https://t.co/ssVYW3M8d7](https://t.co/ssVYW3M8d7)  \\n>\\n> Altair is here; the Merge is coming.  \\n>\\n> tl;dr below\\n> \\n> \u2014 dannyryan \ud83d\ude82 (@dannyryan) [September 28, 2021](https://twitter.com/dannyryan/status/1442873900652646405?ref_src=twsrc%5Etfw)\\n\\nWe first simulated the merge back in April/May of this year.\\n\\n> \\\\> This is the first time all eth2 and eth1 clients communicated with each other in an emulation of the merger which removes Proof of Work miners and fully upgrades the network to Proof of Stake.  \\n>\\n> eth2 progress deniers in disbelief [https://t.co/VGlWCI5d3v](https://t.co/VGlWCI5d3v)\\n> \\n> \u2014 banteg (@bantg) [May 1, 2021](https://twitter.com/bantg/status/1388609381869236227?ref_src=twsrc%5Etfw)\\n\\n  \\nFast forwards 5 months and we\'re finally ready for a more realistic follow-up.\\n\\n> the merge is coming fast. THE MERGE Y\'ALL. arguably the largest event in blockchain history since the bitcoin genesis block. It\'s proof that together we can build a decentralized future, and (responsibly) improve and innovate on the core infrastructure via rough social consensus [https://t.co/2h6GMKF2wJ](https://t.co/2h6GMKF2wJ)\\n> \\n> \u2014 kassandra.eth (@RitualTypist) [September 28, 2021](https://twitter.com/RitualTypist/status/1442888325535125510?ref_src=twsrc%5Etfw)\\n\\nThis time, the interop will [build off Altair](https://hackmd.io/@n0ble/merge-interop-spec), rather than Phase 0.  \\nImportantly, we\'ll be testing the transition mechanism that will take us from a pre to post merge world.\\n\\n> Productionizing the Merge spec includes:  \\n> \\\\- Improving the Consensus API (separating it from the user JSON-RPC)  \\n> \\\\- Implementing the logic for the latest fork-transition approach  \\n> \\\\- Rebase the work onto Altair/London upgrades\\n> \\n> \u2014 proto.eth \ud83d\ude82 \ud83e\udd87 \ud83d\udd0a (@protolambda) [May 12, 2021](https://twitter.com/protolambda/status/1392448056591884288?ref_src=twsrc%5Etfw)\\n\\nThe merge spec has just recently been \\"productionised\\"\\n\\n\\nWe also have a 5th client on the block \xa0:)  \\n\\n> LODESTAR JOINED THE 100% CLUB \ud83d\ude0e Max profitability for a full day on Eth2.0 mainnet.  \\n>\\n> \\\\*I test in prod\\\\* master [@gregthegreek](https://twitter.com/gregthegreek?ref_src=twsrc%5Etfw) plz enjoy your sweet rewards [@ChainSafeth](https://twitter.com/ChainSafeth?ref_src=twsrc%5Etfw) \ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80 [pic.twitter.com/e8RMR8fRdi](https://t.co/e8RMR8fRdi)\\n> \\n> \u2014 Lion \u27e0 dapplion .eth (@dapplion) [September 17, 2021](https://twitter.com/dapplion/status/1438882897260425217?ref_src=twsrc%5Etfw)\\n\\n### Merge quick sync\\n\\nIn general an Ethereum client consists of two layers - the consensus layer and the execution layer.\\n\\nThe consensus layer is responsible for the consensus, i.e. block validity, and fork choice rule. As it stands, on mainnet, we rely on PoW consensus. The Merge enables PoS consensus driven by the beacon chain.\\n\\nThe execution-layer is responsible for transaction bundling, execution, and state management. During the merge this layer will be represented by modified pre-merge PoW clients (eg. geth, nethermind, besu, openethereum, turbogeth, etc).\\n\\nThe key to a successful merge is getting these two layers to talk to each other: the plan right now is for them to interact via a one-way communication protocol, driven by the consensus layer (although this approach is not yet set in stone).\\n\\n> Note that if these layers are bundled into a single piece of software, then the UX of running a post-merge client becomes very similar to running a pre-merge PoW client today (which is precisely why we are working so hard on building out [our execution layer client](https://github.com/status-im/nimbus-eth1)).\\n\\nIf you\'d like to to dig into the details, [this document](https://hackmd.io/@n0ble/merge-interop-spec) specifies the modifications that must be made to beacon chain and pre-merge clients to turn them into a post-merge consensus node and execution engine, respectively.\\n\\n### Our progress\\n\\nWe have passed all the [merge spec tests](https://notes.ethereum.org/@9AeMAlpyQYaAAyuj47BzRw/rkwW3ceVY). If you want to get your hands dirty, you can actually [verify this for yourself](https://github.com/status-im/nimbus-eth2/blob/amphora-merge-interop/docs/interop_merge.md#verify-that-nimbus-runs-through-the-same-examples)!\\n\\nAnd while we\'re waiting for a compatible execution client, we have everything you need to [start experimenting](https://github.com/status-im/nimbus-eth2/blob/amphora-merge-interop/docs/interop_merge.md) on the consensus side.\\n\\n> Eager to get started with [#themerge](https://twitter.com/hashtag/themerge?src=hash&ref_src=twsrc%5Etfw) experiments? Our interop branch has got everything you need for the consensus side: [https://t.co/rRwO27kmaK](https://t.co/rRwO27kmaK)\\n> \\n> \u2014 Nimbus (@ethnimbus) [October 1, 2021](https://twitter.com/ethnimbus/status/1443943484893839370?ref_src=twsrc%5Etfw)\\n\\nYou can keep track of our broader progress [here](https://github.com/status-im/nimbus-eth2/issues/2859).\\n\\n### Interop lock in: round 2\\n\\nIn the [words of Ben Edgington](https://t.co/97X85jdCzM?amp=1), the cat is out of the bag - the eth1 and eth2 client teams will be meeting up in early October to get some Merge devnets running.\\n\\nYou can think of this as round 2 of the interop event we did two years ago.\\n\\nExpect to hear a lot of updates from the client teams as we build out the Merge logic and test our software together on short-lived devnets.\\n\\nIn anticipation, we\'ll leave you with some highlights from the previous lockin.\\n\\n> [#Lighthouse](https://twitter.com/hashtag/Lighthouse?src=hash&ref_src=twsrc%5Etfw) and [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) just finalized a [#Eth2](https://twitter.com/hashtag/Eth2?src=hash&ref_src=twsrc%5Etfw) epoch!  \\n>\\n> As far as I know, this is the first instance of finality on a multi-client Eth2 testnet!  \\n>\\n> Thanks [@protolambda](https://twitter.com/protolambda?ref_src=twsrc%5Etfw), [@dannyryan](https://twitter.com/dannyryan?ref_src=twsrc%5Etfw) for the help. Great work on the networking stack [@AgeManning](https://twitter.com/AgeManning?ref_src=twsrc%5Etfw) and [@jcksie](https://twitter.com/jcksie?ref_src=twsrc%5Etfw)![#Eth2](https://twitter.com/hashtag/Eth2?src=hash&ref_src=twsrc%5Etfw) is coming! [pic.twitter.com/vC5m9OuaT8](https://t.co/vC5m9OuaT8)\\n>\\n> \u2014 Paul Hauner (@paulhauner) [September 9, 2019](https://twitter.com/paulhauner/status/1170952290469122048?ref_src=twsrc%5Etfw)\\n\\n> Artemis just achieved [#interop](https://twitter.com/hashtag/interop?src=hash&ref_src=twsrc%5Etfw) with [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) [pic.twitter.com/JWkIg3XinW](https://t.co/JWkIg3XinW)\\n> \\n> \u2014 Joseph Delong \ud83d\udd31 (@josephdelong) [September 10, 2019](https://twitter.com/josephdelong/status/1171465845513408514?ref_src=twsrc%5Etfw)\\n\\n> Validator monitoring coming to an [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) near you \\\\*soon(TM)\\\\*: [https://t.co/x65lpxJ3t4](https://t.co/x65lpxJ3t4) - based on the excellent and pioneering work done by [@paulhauner](https://twitter.com/paulhauner?ref_src=twsrc%5Etfw) / [@sigp\\\\_io](https://twitter.com/sigp_io?ref_src=twsrc%5Etfw) - by and large compatible metrics make dashboard/monitoring interop easier too!\\n> \\n> \u2014 Jacek Sieka (@jcksie) [September 30, 2021](https://twitter.com/jcksie/status/1443568596865589248?ref_src=twsrc%5Etfw)\\n\\n> Fully autonomous [#eth2](https://twitter.com/hashtag/eth2?src=hash&ref_src=twsrc%5Etfw) beacon chain between [@ethnimbus](https://twitter.com/ethnimbus?ref_src=twsrc%5Etfw) and [#lighthouse](https://twitter.com/hashtag/lighthouse?src=hash&ref_src=twsrc%5Etfw) on a pair of raspberries found in the Canadian wilderness! [pic.twitter.com/Xkps1Yu3DS](https://t.co/Xkps1Yu3DS)\\n> \\n> \u2014 Jacek Sieka (@jcksie) [September 11, 2019](https://twitter.com/jcksie/status/1171886857908609024?ref_src=twsrc%5Etfw)\\n\\n_P.S. Keep your eyes peeled for an [Ethereum Foundation blogpost](https://blog.ethereum.org) on Monday. This will include all mainnet Altair releases. We will also be making a more formal Altair announcement next week._"}]}')}}]);